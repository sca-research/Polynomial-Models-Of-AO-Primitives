using Oscar
using Statistics
include("Ciminion_2.jl")
include("Ciminion_2_polynomial_model.jl")

# ----------------------------------------------------------------------
# Ciminion2 parameters
K = GF(2^13 - 1)
N_trials = 10
rounds_C = 2
max_rounds_E = 15
nr_thrds = 48

sep_1 = repeat("+", 70)
sep_2 = repeat("-", 70)

println("Ciminion2 FGLM")
println("Number of threads: ", nr_thrds)
println("Number of trials: ", N_trials)
println("Field: ", K)
println("Maximal number of rounds: ", rounds_C + max_rounds_E)
println(sep_2)

# ----------------------------------------------------------------------
# Function Declarations
function is_in_shape_position(gb_lex)
    """
    Verifies whether a LEX Gröbner basis
    is in shape position with respect to the
    last variable.

    INPUT:
    "gb_lex" -- A LEX Gröbner basis.
    
    OUTPUT:
    true or false.
    """
    in_shape_position = true
    P = parent(gens(gb_lex)[1])
    with_ordering(P, lex(P)) do
        for poly in gb_lex
            if !is_univariate(poly)
                if !is_univariate(poly - leading_term(poly))
                    in_shape_position = false
                    break
                end
            end
        end
    end
    return in_shape_position
end

function extract_Ciminion_2_gb(ciminion_2)
    """
    Given a Ciminion2 instance, it generates the
    polynomial model for a random nonce, transforms it into a 
    DRL Gröbner basis and returns the quadratic polynomials of
    the basis.

    INPUT:
    "ciminion_2" -- A Ciminion2 instance.

    OUTPUT:
    The quadratic polynomials in a Ciminion2 DRL Gröbner basis.
    In addition, the polynomials are mapped to the polynomial ring
    generated by the non-linear variables only.
    """
    polys = generate_Ciminion_2_polynomials(ciminion_2=ciminion_2, 
                                            info_level=0);

    P = parent(polys[1])
    variables = gens(P)

    variables_Q = String[]
    for var in variables
        push!(variables_Q, string(var))
    end
    variables_Q = [
                   variables_Q[3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E) + 1:3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E) + 2] 
                   variables_Q[1:3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E)];
                   variables_Q[3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E) + 3:3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E) + 3]
                  ]
    Q, variables_Q = polynomial_ring(base_ring(P), variables_Q, internal_ordering=:degrevlex)

    variables_tmp = [
                     variables_Q[2 + 1:2 + 3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E)];
                     variables_Q[1:2];
                     variables_Q[3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E) + 3:3 * (ciminion_2.rounds_C - 1 + ciminion_2.rounds_E) + 3]
                    ]
    h = hom(P, Q, variables_tmp)

    polys = map(h, polys)
    gb = gens(groebner_basis_f4(ideal(polys)))
    polys = gens(groebner_basis_f4(ideal(polys)))

    variables_red = map(i -> variables_Q[2 + 3 * i], 2:(ciminion_2.rounds_C + ciminion_2.rounds_E - 1))
    push!(variables_red, last(variables_Q))
    variables_red = map(string, variables_red)
    P_red, variables_red = polynomial_ring(base_ring(Q), variables_red, internal_ordering=:degrevlex)

    variables_tmp = [zero(P_red), zero(P_red), zero(P_red), zero(P_red), zero(P_red)]
    for i in 1:(ciminion_2.rounds_C + ciminion_2.rounds_E - 2)
        variables_tmp = [variables_tmp; [zero(P_red), zero(P_red)]]
        push!(variables_tmp, variables_red[i])
    end
    push!(variables_tmp, last(variables_red))
    h = hom(Q, P_red, variables_tmp)

    polys = map(h, filter(poly -> total_degree(poly) == 2, polys))

    return polys
end

function bench_fglm(gb_DRL; print_time=true)
    """
    Benchmarks the running time of FGLM.

    INPUT:
    "gb_DRL" -- A DRL Gröbner basis.
    "print_time" -- Print the time to console.
                    Default value is true.
    
    OUTPUT:
    The running time of FGLM.
    """
    P = parent(gb_DRL[1])
    t_1 = time()
    gb_lex = fglm(ideal(gb_DRL), destination_ordering=lex(P))
    t_2 = time()
    t_lex = t_2 - t_1
    if print_time
        println("Time needed for FGLM: ", t_lex, "s")
        println("Shape position: ", is_in_shape_position(gb_lex))
    end
    return t_lex
end

function random_quadratic_polynomial(P)
    """
    Generates a random multivariate quadratic polynomial system.

    INPUT:
    "P" -- A polynomial ring generated by n variables.

    OUTPUT:
    n random multivariate quadratic polynomials.
    """
    K = base_ring(P)
    variables = gens(P)
    quadratic_monoms = vec(map(prod -> prod[1] * prod[2], Iterators.product(variables, variables)))
    poly = [map(mon -> rand(K) * mon, quadratic_monoms);
            map(mon -> rand(K) * mon, variables);
            [rand(K)]
            ]
    return sum(poly)
end

function random_quadratic_DRL_gb(P; nr_thrds=1, print_time=true)
    """
    Generates a random multivariate quadratic polynomial system
    and computes its DRL Gröbner basis.

    INPUT:
    "P" -- A polynomial ring generated by n variables.
    "nr_thrds" -- Number of threads for Gröbner basis computation.
                  Default value is 1.
    "print_time" -- Print the time to console.
                    Default value is true.
    
    OUTPUT:
    The DRL Gröbner basis and the running time for the computation.
    """
    n = length(gens(P))
    polys = map(i -> random_quadratic_polynomial(P), 1:n)
    t_1 = time()
    gb_drl = groebner_basis_f4(ideal(polys), nr_thrds=nr_thrds, info_level=0)
    t_2 = time()
    t_drl = t_2 - t_1
    if print_time
        println("Time needed for random DRL Gröbner basis: ", t_drl, "s")
    end
    return gens(gb_drl), t_drl
end

# ----------------------------------------------------------------------
# Trial run for precompilation
ciminion_2_trial = Ciminion_2_constructor(field=K, 
                                          rounds_C=rounds_C, 
                                          rounds_E=2,
                                          info_level=0)
gb_trial = extract_Ciminion_2_gb(ciminion_2_trial)
P_trial = parent(gb_trial[1])
_t_trial = bench_fglm(gb_trial; print_time=false)
_gb_trial, _t_trial_gb = random_quadratic_DRL_gb(P_trial; nr_thrds=nr_thrds, print_time=false)

# ----------------------------------------------------------------------
# Execution of small scale experiments
for rounds_E in 2:max_rounds_E
    println("Rounds: ", rounds_C + rounds_E)
    times_ciminion_2_fglm = []
    times_rand_drl = []
    times_rand_fglm = []
    for _i in 1:N_trials
        # Ciminion2
        ciminion_2 = Ciminion_2_constructor(field=K, 
                                            rounds_C=rounds_C, 
                                            rounds_E=rounds_E)
        gb = extract_Ciminion_2_gb(ciminion_2)
        P = parent(gb[1])
        t_ciminion_2_fglm = bench_fglm(gb)
        push!(times_ciminion_2_fglm, t_ciminion_2_fglm)
        # Random multivariate quadratic
        gb, t_rand_drl = random_quadratic_DRL_gb(P; nr_thrds=nr_thrds)
        push!(times_rand_drl, t_rand_drl)
        t_rand_fglm = bench_fglm(gb)
        push!(times_rand_fglm, t_rand_fglm)
        println(sep_1)
    end
    println("Times Ciminion2 FGLM: ", times_ciminion_2_fglm)
    println("Mean Ciminion2 FGLM: ", mean(times_ciminion_2_fglm))
    println("Standard deviation Ciminion2 FGLM:: ", std(times_ciminion_2_fglm))

    println("Times Random Quadratic F4: ", times_rand_drl)
    println("Mean Random Quadratic F4: ", mean(times_rand_drl))
    println("Standard deviation Random Quadratic F4: ", std(times_rand_drl))

    println("Times Random Quadratic FGLM: ", times_rand_fglm)
    println("Mean Random Quadratic FGLM: ", mean(times_rand_fglm))
    println("Standard deviation Random Quadratic FGLM: ", std(times_rand_fglm))
    println(sep_2)
end
