using Oscar
using Statistics
include("Hydra.jl")
include("Hydra_polynomial_model.jl")

# ----------------------------------------------------------------------
# Hydra parameters
K = GF(7741)
N_trials = 10
max_rounds = 15
nr_thrds = 48

sep_1 = repeat("+", 70)
sep_2 = repeat("-", 70)

println("Hydra FGLM")
println("Number of threads: ", nr_thrds)
println("Number of trials: ", N_trials)
println("Field: ", K)
println("Maximal number of rounds: ", max_rounds)
println(sep_2)

# ----------------------------------------------------------------------
# Function Declarations
function is_in_shape_position(gb_lex, P)
    """
    Verifies whether a LEX Gröbner basis
    is in shape position with respect to the
    last variable.

    INPUT:
    "gb_lex" -- A LEX Gröbner basis.
    
    OUTPUT:
    true or false.
    """
    in_shape_position = true
    with_ordering(P, lex(P)) do
        for poly in gb_lex
            if !is_univariate(poly)
                if !is_univariate(poly - leading_term(poly))
                    in_shape_position = false
                    break
                end
            end
        end
    end
    return in_shape_position
end

function extract_Hydra_gb(hydra)
    """
    Given a Hydra instance, it generates the
    polynomial model for two samples with a random nonce, 
    extracts its DRL Gröbner basis via a change of coordinates,
    and returns the quadratic polynomials of the basis.

    INPUT:
    "hydra" -- A Hydra instance.

    OUTPUT:
    The quadratic polynomials in a Hydra DRL Gröbner basis.
    In addition, the polynomials are mapped to the polynomial ring
    generated by the non-linear variables only.
    """
    m = 2
    polys = generate_Hydra_polynomials_m_samples(hydra=hydra, m=m, info_level=0);
    polys = transform_Hydra_polynomial_system(hydra, polys, m);
    _, _, polys_downsized_subs = non_linear_variable_substitution_Hydra_polynomial_system(hydra,
                                                                                          polys, 
                                                                                          m; 
                                                                                          transformed=true,
                                                                                          info_level=0);
    P = parent(polys_downsized_subs[1])
    variables_subs = map(i -> "x_subs_i" * string(i), 1:2 * hydra.rounds_head - 2)
    P_subs, variables_subs = polynomial_ring(hydra.field, 
                                             variables_subs, 
                                             internal_ordering=:degrevlex)
    zero_vec = zero_matrix(P_subs, length(gens(P)) - length(variables_subs), 1)
    image = [vec(zero_vec[:, 1]); variables_subs]
    phi = hom(P, P_subs, image)
    polys_downsized_subs = map(phi, polys_downsized_subs)
    gb_subs = [polys_downsized_subs[2 + 1:hydra.rounds_head];
               polys_downsized_subs[2 + hydra.rounds_head + 1:2 * hydra.rounds_head + 2]
               ]
    return gb_subs
end

function bench_fglm(gb_DRL, P; print_time=true)
    """
    Benchmarks the running time of FGLM.

    INPUT:
    "gb_DRL" -- A DRL Gröbner basis.
    "print_time" -- Print the time to console.
                    Default value is true.
    
    OUTPUT:
    The running time of FGLM.
    """
    t_1 = time()
    gb_lex = fglm(ideal(gb_DRL), destination_ordering=lex(P))
    t_2 = time()
    t_lex = t_2 - t_1
    if print_time
        println("Time needed for FGLM: ", t_lex, "s")
        println("Shape position: ", is_in_shape_position(gb_lex, P))
    end
    return t_lex
end

function random_quadratic_polynomial(P)
    """
    Generates a random multivariate quadratic polynomial system.

    INPUT:
    "P" -- A polynomial ring generated by n variables.

    OUTPUT:
    n random multivariate quadratic polynomials.
    """
    K = base_ring(P)
    variables = gens(P)
    quadratic_monoms = vec(map(prod -> prod[1] * prod[2], Iterators.product(variables, variables)))
    poly = [map(mon -> rand(K) * mon, quadratic_monoms);
            map(mon -> rand(K) * mon, variables);
            [rand(K)]
            ]
    return sum(poly)
end

function random_quadratic_DRL_gb(P; nr_thrds=1, print_time=true)
    """
    Generates a random multivariate quadratic polynomial system
    and computes its DRL Gröbner basis.

    INPUT:
    "P" -- A polynomial ring generated by n variables.
    "nr_thrds" -- Number of threads for Gröbner basis computation.
                  Default value is 1.
    "print_time" -- Print the time to console.
                    Default value is true.
    
    OUTPUT:
    The DRL Gröbner basis and the running time for the computation.
    """
    n = length(gens(P))
    polys = map(i -> random_quadratic_polynomial(P), 1:n)
    t_1 = time()
    gb_drl = groebner_basis_f4(ideal(polys), nr_thrds=nr_thrds, info_level=0)
    t_2 = time()
    t_drl = t_2 - t_1
    if print_time
        println("Time needed for random DRL Gröbner basis: ", t_drl, "s")
    end
    return gb_drl, t_drl
end

# ----------------------------------------------------------------------
# Trial run for precompilation
hydra_trial = Hydra_constructor(field=K, 
                                rounds_head=2,
                                info_level=0)
gb_trial = extract_Hydra_gb(hydra_trial)
P_trial = parent(gb_trial[1])
_t_trial = bench_fglm(gb_trial, P_trial; print_time=false)
_gb_trial, _t_trial_gb = random_quadratic_DRL_gb(P_trial; nr_thrds=nr_thrds, print_time=false)

# ----------------------------------------------------------------------
# Execution of small scale experiments
for rounds_head in 3:max_rounds
    println("Rounds: ", rounds_head)
    times_hydra_fglm = []
    times_rand_drl = []
    times_rand_fglm = []
    for _i in 1:N_trials
        hydra = Hydra_constructor(field=K, 
                                  rounds_head=rounds_head,
                                  info_level=0)
        gb = extract_Hydra_gb(hydra)
        P = parent(gb[1])
        t_hydra_fglm = bench_fglm(gb, P)
        push!(times_hydra_fglm, t_hydra_fglm)
        gb, t_rand_drl = random_quadratic_DRL_gb(P; nr_thrds=nr_thrds)
        push!(times_rand_drl, t_rand_drl)
        t_rand_fglm = bench_fglm(gb, P)
        push!(times_rand_fglm, t_rand_fglm)
        println(sep_1)
    end
    println("Times Hydra FGLM: ", times_hydra_fglm)
    println("Mean Hydra FGLM: ", mean(times_hydra_fglm))
    println("Standard deviation Hydra FGLM:: ", std(times_hydra_fglm))

    println("Times Random Quadratic F4: ", times_rand_drl)
    println("Mean Random Quadratic F4: ", mean(times_rand_drl))
    println("Standard deviation Random Quadratic F4: ", std(times_rand_drl))

    println("Times Random Quadratic FGLM: ", times_rand_fglm)
    println("Mean Random Quadratic FGLM: ", mean(times_rand_fglm))
    println("Standard deviation Random Quadratic FGLM: ", std(times_rand_fglm))
    println(sep_2)
end
